\centering \section*{Предшествующие работы}
\centering \subsection*{Задача выбора порядка соединений}

\begin{flushleft}
В статье  Ibaraki \& Kameda \cite{IK} формализуется задача выбора оптимального порядка соединения $n$ таблиц,
при использовании вложенного цикла для сканирования таблиц и результатов соединений. \textbf{Оптимальный вложенный порядок}.
Для заданного набора отношений и предикатов соединения выводится формула ожидаемого числа чтений страниц как функция от порядка соединяемых отношений,
и требуется найти порядок, минимизирующий это значение. Авторы прямо отмечают, что задача нахождения минимального значения этой функции NP-трудная.

Задача выбора оптимального вложенного порядка принимает на вход:
\begin{enumerate}
  \item Статистики для формулы ожидаемого числа чтений страниц.
  \item Описание запроса (граф соединений).
  \item Пороговое значение $B$ --- существует ли такой порядок вложенности отношений, что число чтений страниц $\le B$?
\end{enumerate}
\end{flushleft}

\centering \subsection*{Принадлежность NP}

\begin{flushleft}
Если мы угадали порядок отношений $\pi$, то значение функции числа чтений страниц для $\pi$ вычисляется полиномиально по размеру входа
(это просто вычисление выражения по заданным параметрам). Значит, решение можно проверить за полиномиальное время, тогда задача принадлежит NP.
\end{flushleft}

\centering \subsection*{NP-трудность}

\begin{flushleft}
В доказательстве NP-трудности авторы сводят к этой задаче классическую NP-полную задачу поиска полного графа \cite{RobKarp}:
по графу $G=(V,E)$ и числу $k$ строится экземпляр запроса (в терминах отношений и условий соединения) и подбираются параметры стоимости так, что
существует порядок с числом чтений страниц $\leq B$ тогда и только тогда, когда в $G$ есть полный граф размера $k$.
\end{flushleft}

\centering \subsection*{Пространство поиска планов}

\begin{flushleft}
Пусть даны два отношения R1 и R2, и дан результат их соединения $(R1 \Join R2)$. Назовём R1 - левым сыном, R2 - правым сыном, 
а результат соединения родителем. Тогда получится двоичное дерево. Каждому возможному порядку соединения исходного набора таблиц 
сопоставим двоичное дерево.
\newline

Для заданного начального  дерева  \textbf{пространство поиска планов} \cite{CorrEnum} — это множество всех различных порядков, которые можно получить, 
применяя к начальному плану последовательность из корректных преобразований (они сохраняют эквивалентность результатов, т.е семантическую корректность). 
\newline

Виды корректных преобразований:
\begin{enumerate}
    \item \textbf{Коммутативное}: $(R \Join_{RS} S)$ = $(S \Join_{SR} R)$
    \item \textbf{Ассоциативное}: $(R \Join_{RS} S) \Join_{RT,ST} T$ = $R \Join_{RS,RT} (S \Join_{ST} T)$
    \item \textbf{Левоассоциативное}: $(R \Join_{RS} S) \Join_{RT,ST} T$ = $(R \Join_{RT} T) \Join_{RS,ST} S$
    \item \textbf{Правоассоциативное}: $R \Join_{RS,RT} (S \Join_{ST} T)$ = $S \Join_{RS,ST} (R \Join_{RT} T)$
\end{enumerate}
\end{flushleft}

\centering \subsection*{Жадный подход к планированию}

\begin{flushleft}
В статье \cite{Feg} предлагается эвристический способ построения оптимального порядка, 
путём ухода от экспоненциального перебора порядков соединений, строя порядок соединений жадно снизу-вверх:
\begin{enumerate}
    \item На каждом шаге выбирать такое соединение, что даёт минимальный размер промежуточного результата, с учётом селективностей предикатов.
    \item Соединять выбранные поддеревья.
    \item Обновлять граф запроса новыми оценками размеров/селективностей.
\end{enumerate}

\begin{algorithm}[H]
\caption{GOO$(\{R_1,\dots,R_n\},\,\textit{C}(T_1,T_2))$}
\begin{algorithmic}[1]
\State \textbf{Input:} set of relations to be joined
\State \textbf{Input:} join tree
\State $\textit{Trees} \gets \{R_1,\dots,R_n\}$
\While{$|\textit{Trees}| \neq 1$}
  \State find $T_i,T_j \in \textit{Trees}$ such that $i \neq j$ and
  $\textit{C}(T_i,T_j)$ is minimal among all pairs of trees in $\textit{Trees}$
  \State $\textit{Trees} \gets \textit{Trees}\setminus \{T_i\}$
  \State $\textit{Trees} \gets \textit{Trees}\setminus \{T_j\}$
  \State $\textit{Trees} \gets \textit{Trees}\cup \{T_i \bowtie T_j\}$
\EndWhile
\State \Return the (only) tree contained in $\textit{Trees}$
\end{algorithmic}
\end{algorithm}

Преимущества:
\begin{enumerate}
    \item Эвристика строит ветвистые деревья, что позволяет параллельно исполнять дерево плана.
    \item Полиномиальность по времени планирования $O(n^3)$, где $n$ --- число начальных отношений, вместо экспоненциального времени у полного перебора.
\end{enumerate}

Недостатки:
\begin{enumerate}
    \item Нет гарантий оптимальности: локально лучший шаг может загнать в глобально плохой порядок, классическая проблема жадных алгоритмов.
    \item Зависимость от качества оценок кардинальностей/селективностей: если оценки ошибочны, жадный подход резко деградирует.
\end{enumerate}

В данной статье есть связь с работой \cite{IK}. Так как в общем виде задача выбора оптимального порядка соединения отношений NP-трудная,
то планирование больших запросов требует больших вычислительных ресурсов, следовательно, нужны эвристики.
\newline

В современных СУБД самый распостранённый подход к планированию это \textbf{динамическое программирование}.
Алгоритмы динамического программирования — это методы решения задач оптимизации, которые разбивают исходную задачу на набор перекрывающихся подзадач 
и используют принцип оптимальности: оптимальное решение строится из оптимальных решений подзадач. Вместо повторного пересчёта результатов они их запоминают, 
снижая асимптотическую сложность по сравнению с полным перебором. Такие алгоритмы особенно эффективны, когда пространство решений можно 
параметризовать состояниями (например, подмножествами, интервалами, путями в графе). Цена за ускорение — рост памяти и экспоненциальное число состояний в худшем случае.
\end{flushleft}

\centering \subsection*{Динамическое программирование по размеру подпланов (DPsize)}

\begin{flushleft}
В пособии \cite{Thomas} алгоритм DPsize рассматривается как вариант динамического программирования для построения
оптимального ветвистого дерева соединений при условии, что граф соединений запроса связный.
Алгоритм перечисляет планы в порядке возрастания размера подпланов (числа отношений внутри подплана).

DPsize поддерживает таблицу $BestPlan(S)$, сопоставляющую каждому множеству отношений $S$ лучший (минимальной стоимости) найденный план, и строит планы снизу-вверх:
\begin{enumerate}
    \item Инициализация: для каждого отношения $R_i$ задаётся $BestPlan(\{R_i\}) = R_i$.
    \item Для размера плана $s = 2, \ldots, n$ (по возрастанию) перебираются разбиения $s = s_1 + s_2$, где $1 \le s_1 \le \lfloor s/2 \rfloor$.
    \item Для всех множеств $S_1, S_2$, уже имеющихся в $BestPlan$, таких что $|S_1| = s_1$, $|S_2| = s_2$, проверяется:
    \begin{enumerate}
        \item $S_1 \cap S_2 = \varnothing$ (подпланы не перекрываются),
        \item $S_1$ соединено с $S_2$ хотя бы одним предикатом.
    \end{enumerate}
    \item Если проверки пройдены, строится кандидат $CurrPlan = CreateJoinTree(BestPlan(S_1), BestPlan(S_2))$ и обновляется $BestPlan(S_1 \cup S_2)$, если кандидат дешевле.
\end{enumerate}

\begin{algorithm}[H]
    \caption{DPsize$(\{R_1,\dots,R_n\},\,\textit{C}(T_1,T_2))$}
    \begin{algorithmic}[1]
        \State \textbf{Input:} A set of relations $R = \{R_1, \dots, R_n\}$ to be joined
        \State \textbf{Output:} An optimal bushy join tree
        \State $B \gets$ an empty DP table $2^R \to$ join tree
        \For{\textbf{each} $R_i \in R$}
            \State $B[\{R_i\}] \gets R_i$
        \EndFor
        \For{\textbf{each} $1 < s \leq n$ \textbf{ascending}}
            \For{\textbf{each} $S_1, S_2 \subset R$ \textbf{such that} $|S_1| + |S_2| = s$}
                \If{(\textbf{not} cross products $\land \neg S_1$ connected to $S_2$) $\lor$ $(S_1 \cap S_2 \neq \emptyset)$}
                    \State \textbf{continue}
                \EndIf
                \State $p_1 \gets B[S_1], p_2 \gets B[S_2]$
                \If{$p_1 = \epsilon$ \textbf{or} $p_2 = \epsilon$} \textbf{continue} \EndIf
                \State $P \gets$ CreateJoinTree($p_1, p_2$)
                \If{$B[S_1 \cup S_2] = \epsilon$ \textbf{or} $C(B[S_1 \cup S_2]) > C(P)$}
                    \State $B[S_1 \cup S_2] \gets P$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

Преимущества:
\begin{enumerate}
    \item Оптимальность (в рамках выбранной стоимостной модели и связных графов запросов):
    DPsize перебирает все допустимые соединения подпланов и сохраняет лучший результат для каждого множества $S$.
    \item Структурированное перечисление снизу-вверх по размеру подпланов удобно для реализации.
    \item Зависимость времени от топологии: для цепей и циклов автор приводит полиномиальные формулы числа внутренних проверок (четвёртая степень по $n$),
    что объясняет практическую применимость DPsize на простых топологиях.
\end{enumerate}

Недостатки:
\begin{enumerate}
    \item Худший случай экспоненциален: для звезды и полного графа число комбинаций резко возрастает.
    \item Далёк от нижней границы по перебору: в книге подчёркнуто, что DPsize (как и DPsub) перебирает существенно больше, чем необходимый минимум, что и мотивирует использовать DPccp.
\end{enumerate}

Сложность DPsize от числа отношений $n$:
\begin{align*}
    I^{\text{chain}}_{\text{DPsize}}(n) &=
    \begin{cases}
        \frac{1}{48} (5n^4 + 6n^3 - 14n^2 - 12n), & n \text{ even} \\
        \frac{1}{48} (5n^4 + 6n^3 - 14n^2 - 6n + 11), & n \text{ odd}
    \end{cases}
    \\
    I^{\text{cycle}}_{\text{DPsize}}(n) &=
    \begin{cases}
        \frac{1}{4} (n^4 - n^3 - n^2), & n \text{ even} \\
        \frac{1}{4} (n^4 - n^3 - n^2 + n), & n \text{ odd}
    \end{cases}
    \\
    I^{\text{star}}_{\text{DPsize}}(n) &=
    \begin{cases}
        2^{2n-4} - \frac{1}{4} \binom{2n}{n-1} + q(n), & n \text{ even} \\
        2^{2n-4} - \frac{1}{4} \binom{2(n-1)}{(n-1)} + \frac{1}{4} \binom{(n-1)}{(n-1)/2} + q(n), & n \text{ odd}
    \end{cases}
    \\
    \text{with } q(n) &= n 2^{2n-1} - 5 \times 2^{n-3} + \frac{1}{2} (2^n - 5n + 4)
    \\
    I^{\text{clique}}_{\text{DPsize}}(n) &=
    \begin{cases}
        2^{2n-2} - 5 \times 2^{n-2} + \frac{1}{4} \binom{2n}{n} - \frac{1}{4} \binom{n}{n/2} + 1, & n \text{ even} \\
        2^{2n-2} - 5 \times 2^{n-2} + \frac{1}{4} \binom{2n}{n} + 1, & n \text{ odd}
    \end{cases}
\end{align*}
\end{flushleft}

\centering \subsection*{Динамическое программирование по подмножествам (DPsub)}

\begin{flushleft}
В \cite{Thomas} описывается также вариант динамического программирования для построения оптимального ветвистого 
дерева соединений для связного графа запроса. В отличие от DPsize, где планы строятся по возрастанию размера подпланов, DPsub перебирает все непустые
подмножества исходного множества отношений и для каждого подмножества строит лучший план.

\begin{algorithm}[H]
    \begin{algorithmic}[1]
        \State \textbf{Input:} A set of relations $R = \{R_1, \dots, R_n\}$ to be joined
        \State \textbf{Output:} An optimal bushy join tree
        \State $B \gets$ an empty DP table $2^R \to$ join tree
        \For{\textbf{each} $R_i \in R$}
            \State $B[\{R_i\}] \gets R_i$
        \EndFor
        \For{\textbf{each} $1 < i \leq 2^n - 1$ \textbf{ascending}}
            \State $S \gets \{ R_j \in R \mid ( \lfloor i / 2^{j-1} \rfloor \mod 2) = 1 \}$
            \For{\textbf{each} $S_1, S_2 \subset S$ \textbf{such that} $S_2 = S \setminus S_1$}
                \If{(\textbf{not} cross products $\land \neg S_1$ connected to $S_2$)}
                    \State \textbf{continue}
                \EndIf
                \State $p_1 \gets B[S_1], p_2 \gets B[S_2]$
                \If{$p_1 = \epsilon$ \textbf{or} $p_2 = \epsilon$} \textbf{continue} \EndIf
                \State $P \gets$ CreateJoinTree($p_1, p_2$)
                \If{$B[S] = \epsilon$ \textbf{or} $C(B[S]) > C(P)$}
                    \State $B[S] \gets P$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}

Преимущества:
\begin{enumerate}
    \item Эффективен на плотных пространствах поиска(звезда/полный граф): в таких графах больше связных подмножеств и больше разбиений $S = S_1 \cup S_2$,
    проходящих проверки, поэтому доля холостых итераций меньше; на этих топологиях DPsub начинает выигрывать у DPsize.
    \item Оптимальность (в рамках выбранной стоимостной модели и связных графов запросов):
    DPsub перебирает все допустимые разбиения $S$ на две части и сохраняет лучший план для каждого $S$.
\end{enumerate}

Недостатки:
\begin{enumerate}
    \item Большое количество холостых итераций для простых топологий (цепь/цикл): DPsub перебирает все подмножества $S$, но значительная часть из них несвязна,
    а для связных $S$ большая доля разбиений $(S_1, S_2)$ не проходит проверки связности для соединения.
    \item Далёк от теоретической нижней границы: для большинства топологий число проверок во внутреннем цикле на порядки больше числа количества пар связных подграфов,
    что служит мотивацией перехода к DPccp.
\end{enumerate}

Сложность DPsub от числа отношений $n$:
\begin{align*}
    I^{\text{chain}}_{\text{DPsub}}(n) &= 2^{n+2} - n^{2} - 3n - 4 \\
    I^{\text{cycle}}_{\text{DPsub}}(n) &= n2^{n} + 2^{n} - 2n^2 - 2 \\
    I^{\text{star}}_{\text{DPsub}}(n) &= 2 \times 3^{n-1} - 2^{n} \\
    I^{\text{clique}}_{\text{DPsub}}(n) &= 3^n - 2^{n+1} + 1
\end{align*}
\end{flushleft}


\centering \subsection*{Динамическое программирование по парам связных плдграфов (DPccp)}

\begin{flushleft}
Пусть дан граф соединений $G = (V, E)$. Введём понятие csg-cmp-pair $(S_1, S_2)$ ---
в графе запроса выделим $S_1, S_2$ --- связные непересекающиеся подграфы, такие что $S_1 \subseteq V$,
$S_2 \subseteq V \setminus S_1$ (отсутствие пересечения) и существует между ними ребро.
$S_1, S_2$ в $(S_1, S_2)$ называются комплементарной парой.
\newline

Определим \#csg --- количество связных подграфов, в определении csg-cmp-pair это $S_1$ или $S_2$.
\newline

Определим \#ccp --- количество csg-cmp-pairs.
\newline

В \cite{CCP} предлагается алгоритм DPccp как улучшение DPsize/DPsub для построения оптимального ветвистого дерева для связного 
графа запроса и получения нижней теоретической оценки сложности перебора, которая равна \#ccp.

DPccp поддерживает таблицу $BestPlan(S)$ и вместо перебора всех разбиений подмножеств рассматривает ровно csg-cmp-pairs:
\begin{enumerate}
    \item Инициализация: $BestPlan(\{R_i\}) = R_i$ для всех $R_i$.
    \item Перебор всех csg-cmp-pairs $(S_1, S_2)$; положим $S = S_1 \cup S_2$.
    \item Для текущей пары берутся $p_1 = BestPlan(S_1)$, $p_2 = BestPlan(S_2)$, строится кандидат $CurrPlan = CreateJoinTree(p_1, p_2)$ и обновляется $BestPlan(S)$,
    если кандидат дешевле.
    \item Так как процедура перечисления генерирует только одну ориентацию пары, алгоритм дополнительно учитывает коммутативность соединения, пробуя
    $CreateJoinTree(p_2, p_1)$.
\end{enumerate}

\begin{algorithm}[H]
\caption{DPccp}
\begin{algorithmic}[1]
\State \textbf{Input:} a connected query graph with relations $R=\{R_0,\dots,R_{n-1}\}$
\State \textbf{Output:} an optimal bushy join tree
\ForAll{$R_i \in R$}
    \State $\texttt{BestPlan}(\{R_i\}) \gets R_i$
\EndFor
\ForAll{csg-cmp-pairs $(S_1,S_2)$, $S = S_1 \cup S_2$}
    \State $\texttt{InnerCounter} \gets \texttt{InnerCounter} + 1$
    \State $p_1 \gets \texttt{BestPlan}(S_1)$
    \State $p_2 \gets \texttt{BestPlan}(S_2)$
    \State $\texttt{CurrPlan} \gets \texttt{CreateJoinTree}(p_1,p_2)$
    \If{$\texttt{cost}(\texttt{BestPlan}(S)) > \texttt{cost}(\texttt{CurrPlan})$}
        \State $\texttt{BestPlan}(S) \gets \texttt{CurrPlan}$
    \EndIf
    \State $\texttt{CurrPlan} \gets \texttt{CreateJoinTree}(p_2,p_1)$
    \If{$\texttt{cost}(\texttt{BestPlan}(S)) > \texttt{cost}(\texttt{CurrPlan})$}
        \State $\texttt{BestPlan}(S) \gets \texttt{CurrPlan}$
    \EndIf
\EndFor
\State \Return $\texttt{BestPlan}(\{R_0,\dots,R_{n-1}\})$
\end{algorithmic}
\end{algorithm}

Преимущества:
\begin{enumerate}
    \item Достижение нижней границы перебора: DPccp рассматривает ровно ccp; в тексте подчёркивается, что это является нижней границей для DP.
\end{enumerate}

Недостатки:
\begin{enumerate}
    \item Худший случай всё равно экспоненциален: на полных графах число \#ccp очень быстро возрастает, и DPccp также становится очень дорогим.
    \item Сложность реализации: нужно эффективно перечислять csg-cmp-pairs без дубликатов и в порядке, корректном для DP,
    чтобы перед $(S_1, S_2)$ уже были рассмотрены все непустые подмножества.
\end{enumerate}

Сложность DPccp от числа отношений $n$:
\[
I^{\text{chain}}_{\text{DPсcp}}(n) =
n^3
\]

\[
I^{\text{cycle}}_{\text{DPccp}}(n) =
n^3
\]

\[
I^{\text{star}}_{\text{DPccp}}(n) =
n2^n
\]

\[
I^{\text{clique}}_{\text{DPccp}}(n) =
3^n
\]
В статье алгоритм DPccp перечисляет csg-компоненты $S_1$ (связные подмножества) в порядке, согласованном с DP, используя нумерацию, построенную поиском в ширину, вершин и запрет на включение вершин с меткой меньше стартовой, чтобы не порождать дубликаты.
Для каждого $S_1$ процедура \texttt{EnumerateCmp} строит вторую часть пары $S_2$ только внутри дополнения $V\setminus S_1$: стартует с одиночных вершин из окрестности $(S_1)$ и затем рекурсивно расширяет их, добавляя подмножества соседей уже построенного $S_2$ (то есть всегда растит связный компонент).
Параметр исключения $X$ выбирается так, чтобы $S_2$ не содержал вершин с меткой меньше любой вершины из $S_1$ (условие порядка $min(S_1) < min(S_2)$), что устраняет симметричные дубликаты $(S_1,S_2)$ / $(S_2,S_1)$.
Из-за старта из окрестности $(S_1)$ и связного расширения гарантируется смежность $S_2$ к $S_1$ (есть ребро между компонентами), поэтому перечисляются ровно допустимые csg-cmp-пары.
\end{flushleft}


\centering \subsection*{DPhyp: динамическое программирование на гиперграфах}

\begin{flushleft}
В другой статье, от тех же авторов \cite{MoeNeu} замечается, что
DPccp эффективен для связных графов запросов, в котором все соединения inner join и являются бинарными, т.е каждое условие включает ровно две таблицы: 
Однако реальные запросы содержат \emph{сложные предикаты}, связывающие сразу несколько отношений, 
и \emph{non-inner joins} с ограничениями на перестановки. DPhyp обобщает DPccp на эти случаи 
за счёт представления запроса в виде \emph{гиперграфа}.
\end{flushleft}

\centering \subsubsection*{Гиперграф и csg-cmp-пары}
\begin{flushleft}
Запрос представим гиперграфом $H=(V,E)$, где $V$ --- таблицы, а гиперребро $e=(U,W)$ связывает две непересекающиеся группы $U,W\subseteq V$, $U\cap W=\emptyset$ (частный случай $|U|=|W|=1$ даёт обычное ребро).
\newline

Комплементарная пара определяется аналогично, только вместо рёбер гиперёбра.
\end{flushleft}

\centering \subsubsection*{Идея перечисления}
\begin{flushleft}
DPhyp перечисляет аналогично только ccp.
Вводится линейный порядок на отношениях $\prec$ и правило уникальности: рассматриваются только пары с $\min(S_1)\prec \min(S_2)$ , где $\min(S)$ - минимальный номер вершины, 
входящей в S. Порядок нужен, чтобы симметричные дубликаты не порождались.
\newline

Компоненты строятся рекурсивным расширением через \emph{окрестность} $N(S,X)$ --- разрешённые узлы, достижимые из $S$ по гиперрёбрам, исключая запрещённые $X$.
\newline

Пусть есть цепочка $R_1\!-\!R_2\!-\!R_3$, цепочка $R_4\!-\!R_5\!-\!R_6$ и гиперребро между $\{R_1,R_2,R_3\}$ и $\{R_4,R_5,R_6\}$.
Тогда $(S_1,S_2)=(\{R_1,R_2,R_3\},\{R_4,R_5,R_6\})$ --- валидная csg-cmp-pair: обе стороны связны и соединяемы гиперребром.
Характерная ситуация: при $S_1=\{R_1,R_2,R_3\}$ окрестность даёт вход $\min(\{R_4,R_5,R_6\})=R_4$, и процедура \texttt{EnumerateCmpRec} достраивает $S_2$ до полной тройки, после чего пара становится соединяемой.

\begin{figure}[t]
\centering
\begin{tikzpicture}[node distance=8mm and 22mm]
  \node (R1) {$R_1$};
  \node (R2) [below=of R1] {$R_2$};
  \node (R3) [below=of R2] {$R_3$};

  \node (R4) [right=40mm of R1] {$R_4$};
  \node (R5) [below=of R4] {$R_5$};
  \node (R6) [below=of R5] {$R_6$};

  \node[inner sep=0pt, minimum size=0pt] (J1) [right=14mm of R2] {};
  \node[inner sep=0pt, minimum size=0pt] (J2) [left=14mm of R5] {};

  % простые ребра
  \draw (R1) -- (R2) -- (R3);
  \draw (R4) -- (R5) -- (R6);

  % гиперребро (как на Fig. 2)
  \draw (R1) -- (J1) -- (R3);
  \draw (J1) -- (J2);
  \draw (R4) -- (J2) -- (R6);
\end{tikzpicture}
\caption{Пример гиперграфа}
\label{fig:dphyp-sample-hypergraph}
\end{figure}
\end{flushleft}

\centering \subsubsection*{DPhyp}
\begin{flushleft}

\begin{algorithm}[H]
\caption{DPhyp (перечисление csg-cmp-пар)}
\begin{algorithmic}[1]
\State \textbf{Input:} Гиперграф запроса $H=(V,E)$, порядок $\prec$ на $V$
\State \textbf{Output:} an optimal bushy join tree.

\State \textbf{global} $dp[\cdot]$ \Comment{DP-таблица: множество отношений $\to$ оптимальный план}

\Function{Solve}{}
  \ForAll{$v \in V$}
    \State $dp[\{v\}] \gets \Call{Scan}{v}$
  \EndFor
  \ForAll{$v \in V$ \textbf{in descending} $\prec$}
    \State \Call{EmitCsg}{$\{v\}$}
    \State $B_v \gets \{\,w \in V \mid w \prec v\,\} \cup \{v\}$
    \State \Call{EnumerateCsgRec}{$\{v\}, B_v$}
  \EndFor
  \State \Return $dp[V]$
\EndFunction

\Function{EnumerateCsgRec}{$S_1, X$}
  \State $Y \gets \Call{Neighborhood}{S_1, X}$
  \ForAll{$N \subseteq Y$ \textbf{with} $N \neq \emptyset$}
    \If{\Call{Connected}{$S_1 \cup N$}}
      \State \Call{EmitCsg}{$S_1 \cup N$}
      \State \Call{EnumerateCsgRec}{$S_1 \cup N,\; X \cup Y$}
    \EndIf
  \EndFor
\EndFunction

\Function{EmitCsg}{$S_1$}
  \State $X \gets S_1 \cup B_{\min(S_1)}$
  \State $Y \gets \Call{Neighborhood}{S_1, X}$
  \ForAll{$v \in Y$ \textbf{in descending} $\prec$}
    \State $S_2 \gets \{v\}$
    \If{\Call{Joinable}{$S_1, S_2$}}
      \State \Call{EmitCsgCmp}{$S_1, S_2$}
    \EndIf
    \State \Call{EnumerateCmpRec}{$S_1, S_2, X$}
  \EndFor
\EndFunction

\Function{EnumerateCmpRec}{$S_1, S_2, X$}
  \State $Y \gets \Call{Neighborhood}{S_2, X}$
  \ForAll{$N \subseteq Y$ \textbf{with} $N \neq \emptyset$}
    \If{\Call{Connected}{$S_2 \cup N$} \textbf{and} \Call{Joinable}{$S_1, S_2 \cup N$}}
      \State \Call{EmitCsgCmp}{$S_1, S_2 \cup N$}
    \EndIf
    \State \Call{EnumerateCmpRec}{$S_1, S_2 \cup N, X$}
  \EndFor
\EndFunction

\Function{EmitCsgCmp}{$S_1, S_2$}
  \State $S \gets S_1 \cup S_2$
  \State $p \gets \Call{PredicatesBetween}{S_1, S_2}$
  \State $cand \gets \Call{Join}{dp[S_1], dp[S_2], p}$
  \If{$dp[S] = \epsilon$ \textbf{or} $C(dp[S]) > C(cand)$}
    \State $dp[S] \gets cand$
  \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}

Для не inner join порядок перестановок ограничен семантикой, поэтому часть разбиений заведомо не корректна.
\newline

Идея статьи: закодировать такие ограничения в структуре гиперграфа,добавляя ограничивающие гиперребра, чтобы алгоритм DP перечислял только допустимые комбинации.
\end{flushleft}

\centering \subsection*{Генетический подход}

\begin{flushleft}
В работе \cite{GEN} предлагается генетический алгоритм для оптимизации запросов соединения как альтернатива классическому
динамическому программированию типа DPsize.
Качество построенного дерева плана определяется стоимостной моделью, которая переводится
в функцию приспособленности. Алгоритм пытается её минимизировать.
Алгоритм поддерживает популяцию планов кандидатов, итеративно применяя селекцию, перемещение и мутацию.

\textbf{Ключевые идеи}:
\begin{enumerate}
    \item Два пространства поиска (strategy spaces):
    \begin{enumerate}
        \item $L$ --- только left-deep планы (линейные деревья).
        \item $A$ --- более общее пространство, включающее bushy планы (ветвистые деревья).
    \end{enumerate}
    Оптимальный план часто лежит вне $L$, поэтому для выигрыша по качеству требуется искать в $A$.
    \item Кодирование планов (chromosome encoding):
    \begin{enumerate}
        \item Для $L$: хромосома --- упорядоченный список генов вида (отношение, метод соединения).
        \item Для $A$: хромосома --- упорядоченный список генов, где каждый ген соответствует конкретному соединению из графа запроса,
        вместе с методом соединения и информацией о порядке.
    \end{enumerate}
    \item Локальная селекция (local neighborhood GA): вместо глобальной селекции используется схема локальной окрестности,
    где отбор партнёров для скрещивания происходит внутри локального окружения хромосомы.
    \item Операторы поиска:
    \begin{enumerate}
        \item Мутации: (i) случайная смена метода соединения; (ii) локальная перестановка соседних генов.
        \item Перемещение: M2S (modified two swap) и CHUNK (перенос случайного непрерывного фрагмента генов).
    \end{enumerate}
\end{enumerate}

\textbf{Преимущества}
\begin{enumerate}
    \item Масштабируемость для больших запросов: алгоритм не требует DP-таблиц экспоненциального размера и остаётся применимым там,
    где DPsize становится непрактичным из-за потребления памяти.
    \item Возможность улучшать планы относительно левосторонних деревьев: поиск в $A$ позволяет находить ветвистые планы, которые по стоимости могут быть лучше лучшего левостороннего плана.
    \item Хорошая параллелизуемость: популяционная природа GA естественно переносится на параллельную архитектуру с небольшими коммуникационными затратами.
\end{enumerate}

\textbf{Недостатки}
\begin{enumerate}
    \item Нет гарантий оптимальности и стабильности: по мере роста размера запроса качество решений и устойчивость сходимости ухудшаются из-за резкого роста пространства стратегий.
    \item Чувствительность к параметрам: качество зависит от размера популяции, выбора операторов перемещения/мутации и схемы селекции; неудачные настройки дают деградацию.
    \item Затраты на оценку приспособленности: нужно многократно вычислять стоимость планов для большого числа хромосом, что может доминировать во времени оптимизации.
\end{enumerate}
\end{flushleft}

\centering \subsection*{Использование графовых топологий при оценке эвристик}
\begin{flushleft}

В пособии \cite{ALL} автор использует типовые топологии (цепь, цикл, звезда, полный граф) как контролируемые модели различных классов графов соединений,
чтобы сравнить поведение алгоритмов на структурах с разной плотностью рёбер и разными размерами.
Отдельно подчёркивается, что эффективность оптимизаторов зависит от структуры графа.
Например, цепь и звезда с одинаковым числом таблиц имеют разное время планирования.
\newline
\textbf{Подход: жадная эвристика и сравнение по топологиям}\\
Основной исследуемый алгоритм это жадный подход, описанный выше.

\textbf{Ключевые идеи оценки}
\begin{enumerate}
    \item Сравнить жадный подход и динамическое программирование по двум метрикам: (i) стоимость найденного плана, (ii) время оптимизации (runtime).
    \item Выполнить сравнение на пяти графах: цепь, цикл, звезда, полный граф (синтетические топологии) и бенчмарке IMDB (реальный граф отношений),
    чтобы выявить влияние топологии на качество/время.
    \item Выявлено эмпирическое правило: для простых топологий (цепь и цикл) динамическое программирование доминирует по стоимости и часто по времени планирования,
    а для более сложных (звезда, полный граф) динамическое программирование остаётся лучшим по стоимости,
    но начинает резко проигрывать по времени планирования при росте числа отношений.
\end{enumerate}

\textbf{Преимущества жадного подхода}
\begin{enumerate}
    \item Полиномиальное время планирования и хорошая масштабируемость по времени планирования на больших запросах.
    \item Топологии показывают, что порог по числу таблиц недостаточен --- важна форма графа соединений.
\end{enumerate}

\textbf{Недостатки}
\begin{enumerate}
    \item Качество планов по стоимости хуже, чем у DP почти на всех топологиях.
    \item На IMDB жадный подход нестабилен по стоимости. Автор фиксирует большую разницу стоимости относительно синтетических топологий
    и существенно более высокие стоимости у GOO на большинстве размеров.
\end{enumerate}
\end{flushleft}

\centering \subsection*{Адаптивная оптимизация очень больших запросов соединения}
\begin{flushleft}
В статье \cite{Adaptive} предлагается адаптивный фреймворк оптимизации порядка соединений,
который выбирает (и переключает) стратегию планирования по сложности графа соединений и заданному бюджету перебора,
чтобы для типичных запросов получать оптимум, а для больших деградировать по качеству плавно и предсказуемо по времени оптимизации.
\newline

\textbf{Понятие адаптивности}
Под адаптивностью в работе понимается не фиксированное правило вида DP до $N$ таблиц, дальше эвристика,
а выбор алгоритма по структуре (топологии) графа запроса и контроль затрат оптимизации через бюджет перечисления.
В результате малые/простые запросы решаются точно, а большие обрабатывается эвристически,
но с контролируемым временем оптимизации.

\textbf{Ключевые идеи и особенности адаптивного планирования}
\begin{enumerate}
    \item Оценка сложности через число связных подграфов.
    Авторы считают \#ccp графа соединений. Это число совпадает с размером полной DP-таблицы (коррелирует со временем оптимизации). 
    Если число связных подграфов не превышает заданного порога, то графовый DP (DPhyp) считается быстрым,
    и запрос оптимизируется точно.
    \item Линеаризация для средних запросов.
    Когда полный DP становится слишком дорогим, вводится линеаризация пространства поиска:
    сначала строится линейный порядок отношений, затем DP ограничивается только связными подцепочками этого порядка,
    вместо произвольных подмножеств. Это уменьшает размер DP-таблицы с $O(2^n)$ до $O(n^2)$ (и делает время порядка $O(n^3)$).
    Качество плана зависит от выбранного порядка: при ``плохой'' линеаризации некоторые хорошие порядки соединений становятся недостижимыми.
    Кроме того, гипер-рёбра не выражаются линейно, поэтому linearized DP применима только к обычным графам соединений.
    \item GOO + локальная оптимизация больших поддеревьев для очень больших запросов.
    Для очень больших запросов строится начальный план жадной эвристикой (GOO), после чего выполняется итеративное улучшение:
    выбранные (дорогие) поддеревья перепланируются более точным методом DP, но только до размера $k$.
\end{enumerate}

\textbf{Преимущества}
\begin{enumerate}
    \item Оптимальность для частого случая: если граф достаточно простой по \#ccp бюджету, фреймворк гарантированно запускает DPHyp и находит оптимальный порядок.
    \item Масштабирование до тысяч отношений: при росте размера запроса происходит переход к менее дорогим стадиям.
    \item Плавная деградация качества.
    \item Учитывается форма графа запроса: выбор алгоритма определяется не только числом начальных отношений, что точнее отражает реальную сложность перечисления.
\end{enumerate}

\textbf{Недостатки}
\begin{enumerate}
    \item Линеаризация неприменима при внешних соединениях и гиперрёбрах
    \item Зависимость качества от линеаризации: выбранный линейный порядок ограничивает пространство планов, некоторые хорошие порядки соединений становятся недостижимыми.
    \item Локальность улучшений в GOO-DP: перепланирование поддеревьев размера $k$ не даёт полной свободы глобальных перестановок между различными поддеревьями,
    поэтому итог может оставаться далёким от оптимума.
    \item Пороговые параметры являются эвристическими: бюджет, границы и $k$ определяют поведение и требуют настройки под конкретную систему и модель стоимости.
\end{enumerate}
\end{flushleft}

\centering \subsection*{Оценки в модели стоимости}
\begin{flushleft}

В статье \cite{HowGood} отмечают, что оптимизатор СУБД выбирает план выполнения по стоимостной модели, опираясь на оценки селективностей и кардинальностей 
промежуточных результатов. Если эти оценки сильно ошибочны (происходит из-за предположений о независимости предикатов 
и упрощённых статистик), оптимизатор может выбрать плохой порядок соединений и неподходящие алгоритмы, что приводит к кратному 
(иногда на порядки) замедлению выполнения запроса.
\newline

Авторы предлагают измерять качество оптимизатора не абстрактно, а на контролируемой постановке: берётся набор реальных запросов и сравниваются:
\begin{enumerate}
    \item Ошибки оценок кардинальностей.
    \item Итоговое время выполнения при разных условиях.
\end{enumerate}

Используется  Join Order Benchmark (JOB) на базе IMDb: 113 запросов с множественными соединениями и фильтрами.
Модифицируется PostgreSQL так, чтобы оптимизатор мог получать \emph{истинные} кардинальности 
(как будто статистика идеальна). Это позволяет отделить влияние ошибок оценок от прочих факторов и ответить на вопрос: насколько улучшится план и время выполнения, если убрать только ошибки селективности/кардинальности.
Дополнительно анализируется роль качества стоимостной модели и объёма перебора планов 
(полный DP-поиск против ограниченных эвристик).
\newline

Выводы:
\begin{enumerate}
\item Ошибки оценок кардинальностей встречаются часто и могут быть очень большими, особенно в запросах с множеством соединений и коррелированными условиями. 
\item Главный источник плохих планов --- именно ошибки кардинальностей: при доступе к точным размерам оптимизатор существенно чаще выбирает правильный порядок соединений и более подходящие алгоритмы, что заметно ускоряет выполнение.
\item Точность самой стоимостной функции оказывает меньший эффект: упрощение параметров стоимости обычно меньше влияет на качество плана, чем исправление кардинальностей.
\item Полноценный перебор даёт преимущество над ограниченными стратегиями поиска: даже при неточных оценках он реже пропускает хороший порядок соединений, тогда как ограниченный поиск может застрять на неудачном плане.
\item При этом оптимизатор часто остаётся достаточно хорошим на практике: многие планы устойчивы к ошибкам (например, хеш-соединения), а катастрофические провалы возникают в сравнительно редких сочетаниях (глубокие деревья соединений, сильные ошибки, рискованные выборы больших вложенное сканирование).
\end{enumerate}
\end{flushleft}