\centering \section*{Введение}
\begin{flushleft}


Современные СУБД работают с большим объёмом информации и транзакций, используя для ввода запросов язык SQL. 
С ростом количества данных увеличивается и время, необходимое для выполнения запросов. 
Сокращение этого времени выполнения запросов становится важным фактором для удобства и эффективности СУБД. 
\newline

В процессе трансляции запрос превращается сначала в логическое представление в виде дерева, 
затем с помощью оптимизатора СУБД в физический план исполнения. Производительность СУБД напрямую зависит от качества
построенного физического плана. Для создания "хорошего" плана нужно решить или приблизить решение
NP-трудной задачи выбора оптимального порядка соединений таблиц, так как оно требует сложных вычислений и значительных затрат ресурсов операционной системы.
В процессе работы оптимизатора, решается вопрос какой тип соединения использовать, как и в каком порядке соединить таблицы. Запрос преобразуется в набор планов.
\newline

\textbf{Соединение таблиц} -- это операция, которая позволяет объединять данные
из двух и более таблиц по определённому условию. Использование соединений необходимо,
когда информация распределена между несколькими таблицами. Соединение принимает два аргумента, 
назовём первый аргумент левым, второй правым. Каждый аргумент это таблица, либо результат соединения нескольких 
таблиц.
\newline

\textbf{Отношение} -- либо единичная таблица, либо результат соединения нескольких таблиц.
\newline

\textbf{Виды соединений таблиц}:
\begin{enumerate}
  \item \textbf{Inner join} - возвращает только те строки, для которых условие связи выполняется в обоих аргументах.
  \item \textbf{Outer join} - возвращает все строки из одной или обоих аргументов, дополняющее 
  отсутствующие совпадения пустыми значениями. Существует три вида внешних соединений.
  \begin{enumerate}
        \item \textbf{LEFT OUTER JOIN} - возвращает все строки из левого аргумента и совпадения из правого.
        \item \textbf{RIGHT OUTER JOIN} - возвращает все строки из правого аргумента и совпадения из левого.
        \item \textbf{FULL OUTER JOIN} - возвращает объединение всех строк из обоих аргументов.
  \end{enumerate}
  \item \textbf{SEMI JOIN} - возвращает строки из левого аргумента по существованию хотя бы одного совпадения в правом аргументе.
  \item \textbf{Anti join} - это операция, обратная SEMI JOIN, которая возвращает строки из левого аргумента только при отсутствии совпадений в правом.
  \item \textbf{Cross join} - соединяет каждую строку левого аргумента с каждой строкой правого. Выполняет соединение без условия.
\end{enumerate}

Оптимизатор СУБД использует стоимостную модель (cost model), которая преобразует прогнозы использования различных ресурсов в одно число. 
\textbf{Стоимость}. 
Ключевые компоненты, которые учитываются, это:
\begin{enumerate}
  \item Стоимость чтения/записи одной единицы данных, находящихся на ПЗУ.
  \item Стоимость чтения/записи одной единицы данных, находящихся на ОЗУ.
  \item Стоимость обработки одной единицы данных ЦПУ.
  \item Стоимость передачи одной единицы данных по сети.
  \item Стоимость использования памяти
\end{enumerate}

Каждый план можно представить в виде дерева, вершинами в котором являются отношения. Рёбра — условия соединения отношений.
При этом операция соединения не ассоциативна по стоимости, то есть
$(R1 \Join R2) \Join R3 \neq R1 \Join (R2 \Join  R3)$.
\newline

Выбор, в какой последовательности нужно соединить таблицы, является задачей выбора 
порядка соединений. Различные планы исполнения для одного и того же запроса возвращают 
одинаковый результат, но время и ресурсы (CPU, память, I/O обращения, возможно 
сетевые ресурсы), необходимые для выполнения запроса, сильно различаются. Поэтому 
выбор оптимального плана позволяет сократить время отклика, минимизировать 
потребление ресурсов и эффективно обрабатывать большие массивы данных, значительно 
повышая удобство работы пользователя.
\newline

Комбинаторная природа задачи видна через простую оценку. Если соединения выполнять бинарно, форма плана задаётся двоичным деревом 
с \(n\) листьями(таблицами). Таких структур \(C_{n-1}\), где \(C_k\) — число Каталана; асимптотически \(C_n \sim \dfrac{4^n}{n^{3/2}\sqrt{\pi}}\). 
Даже без учёта перестановок самих отношений это уже экспоненциальный рост количества возможных планов.
\newline

В работе запрос рассматривается как (гипер)граф соединений. Вершины — отношения (таблицы), рёбра — условия соединений. Рёбра, 
затрагивающие более двух таблиц -- гипер-рёбра. 
Ситуацию осложняют внешние соединения (\texttt{OUTER JOIN}): в общем случае они семантически не ассоциативны и не коммутативны, 
следовательно, ограничивают допустимые переупорядочивания.
\newline

Можно заметить, что гиперграф запроса можно разбить на различные топологии: цепи, циклы, звёзды, плотные графы. Количество 
возможных планов у двух топологий (с обычными рёбрами и без внешних соединений) от одинакового числа таблиц может отличаться в несколько 
раз, при увеличении количества таблиц разница может вырасти до нескольких порядков.
\newline

На практике индустриальные СУБД комбинируют подходы. Для малого числа таблиц применяют динамическое программирование (перебор 
подмножеств с запоминанием лучших частичных планов). При росте количества таблиц переключаются на эвристики: жадные 
стратегии, локальные улучшения, генетические алгоритмы и их простые сочетания. У такого подхода есть существенный недостаток: 
количество возможных планов коррелирует с числом таблиц, но линейная зависимость отсутствует.
Также в индустрии есть спрос на тарифицируемое планирование и исполнение запросов: хотелось бы иметь возможность задать ограниченный 
бюджет на обработку запроса.
\newline

В данной работе предлагаются методы адаптивного планирования запросов, которые включают в себя:
\begin{enumerate}
  \item Различные эвристики для планирования запроса.
  \item Критерии для выбора эвристик для планирования запроса.
  \item Критерии для динамического переключения между эвристиками во время планирования.
  \item Реализацию динамическое переключение между эвристиками в зависимости от критериев. 
\end{enumerate}
\end{flushleft}